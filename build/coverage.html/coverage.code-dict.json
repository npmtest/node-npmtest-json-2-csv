{"/home/travis/build/npmtest/node-npmtest-json-2-csv/test.js":"/* istanbul instrument in package npmtest_json_2_csv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-2-csv/lib.npmtest_json_2_csv.js":"/* istanbul instrument in package npmtest_json_2_csv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_json_2_csv = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_json_2_csv = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-json-2-csv/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-json-2-csv && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_json_2_csv */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_json_2_csv\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_json_2_csv.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_json_2_csv.rollup.js'] =\n            local.assetsDict['/assets.npmtest_json_2_csv.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_json_2_csv.__dirname +\n                    '/lib.npmtest_json_2_csv.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-json-2-csv/node_modules/json-2-csv/lib/converter.js":"'use strict';\n\nvar json2Csv = require('./json-2-csv'), // Require our json-2-csv code\n    csv2Json = require('./csv-2-json'), // Require our csv-2-json code\n    constants = require('./constants.json'), // Require in constants\n    docPath = require('doc-path'),\n    _ = require('underscore'); // Require underscore\n\n/**\n * Default options\n */\nvar defaultOptions = constants.DefaultOptions;\n\nvar isDefined = function (val) {\n    return !_.isUndefined(val);\n};\n\nvar copyOption = function (options, lowercasePath, uppercasePath) {\n    var lowerCaseValue = docPath.evaluatePath(options, lowercasePath);\n    if (isDefined(lowerCaseValue)) {\n        docPath.setPath(options, uppercasePath, lowerCaseValue);\n    }\n};\n\n/**\n * Build the options to be passed to the appropriate function\n * If a user does not provide custom options, then we use our default\n * If options are provided, then we set each valid key that was passed\n */\nvar buildOptions = function (opts, cb) {\n    // PREVIOUS VERSION SUPPORT (so that future versions are backwards compatible)\n    // Issue #26: opts.EOL should be opts.DELIMITER.EOL -- this will move the option & provide backwards compatibility\n    if (docPath.evaluatePath(opts, 'EOL')) { docPath.setPath(opts, 'DELIMITER.EOL', opts.EOL); }\n    \n    // #62: Allow for lower case option names\n    if (opts) {\n        copyOption(opts, 'prependHeader', 'PREPEND_HEADER');\n        copyOption(opts, 'trimHeaderFields', 'TRIM_HEADER_FIELDS');\n        copyOption(opts, 'sortHeader', 'SORT_HEADER');\n        copyOption(opts, 'parseCsvNumbers', 'PARSE_CSV_NUMBERS');\n        copyOption(opts, 'keys', 'KEYS');\n        copyOption(opts, 'checkSchemaDifferences', 'CHECK_SCHEMA_DIFFERENCES');\n        copyOption(opts, 'emptyFieldValue', 'EMPTY_FIELD_VALUE');\n        if (isDefined(opts.delimiter)) { \n            copyOption(opts, 'delimiter.field', 'DELIMITER.FIELD');\n            copyOption(opts, 'delimiter.array', 'DELIMITER.ARRAY');\n            copyOption(opts, 'delimiter.wrap', 'DELIMITER.WRAP');\n            copyOption(opts, 'delimiter.eol', 'DELIMITER.EOL');\n        }\n    }\n\n    opts = _.defaults(opts || {}, defaultOptions);\n\n    // Note: _.defaults does a shallow default, we need to deep copy the DELIMITER object\n    opts.DELIMITER = _.defaults(opts.DELIMITER || {}, defaultOptions.DELIMITER);\n\n    // If the delimiter fields are the same, report an error to the caller\n    if (opts.DELIMITER.FIELD === opts.DELIMITER.ARRAY) { return cb(new Error(constants.Errors.delimitersMustDiffer)); }\n    \n    // Otherwise, send the options back\n    return cb(null, opts);\n};\n\n// Export the following functions that will be client accessible\nmodule.exports = {\n\n    /**\n     * Client accessible json2csv function\n     * Takes an array of JSON documents to be converted, a callback that will be called with (err, csv)\n     * after processing is complete, and optional options\n     * @param array Object[] data to be converted\n     * @param callback Function callback\n     * @param opts Object options object\n     */\n    json2csv: function (array, callback, opts) {\n        // If this was promisified (callback and opts are swapped) then fix the argument order.\n        if (_.isObject(callback) && !_.isFunction(callback)) {\n            var func = opts;\n            opts = callback;\n            callback = func;\n        }\n\n        buildOptions(opts, function (err, options) { // Build the options\n            if (err) {\n                return callback(err);\n            } else {\n                json2Csv.json2csv(options, array, callback); // Call our internal json2csv function\n            }\n        });\n    },\n\n    \n    /**\n     * Client accessible csv2json function\n     * Takes a string of CSV to be converted to a JSON document array, a callback that will be called\n     * with (err, json) after processing is complete, and optional options\n     * @param csv\n     * @param callback\n     * @param opts\n     */\n    csv2json: function (csv, callback, opts) {\n        // If this was promisified (callback and opts are swapped) then fix the argument order.\n        if (_.isObject(callback) && !_.isFunction(callback)) {\n            var func = opts;\n            opts = callback;\n            callback = func;\n        }\n\n        buildOptions(opts, function (err, options) { // Build the options\n            if (err) {\n                return callback(err);\n            } else {\n                csv2Json.csv2json(options, csv, callback); // Call our internal csv2json function\n            }\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-json-2-csv/node_modules/json-2-csv/lib/json-2-csv.js":"'use strict';\n\nvar _ = require('underscore'),\n    constants = require('./constants.json'),\n    path = require('doc-path'),\n    promise = require('bluebird');\n\nvar options = {}; // Initialize the options - this will be populated when the json2csv function is called.\n\n/**\n * Retrieve the headings for all documents and return it.\n * This checks that all documents have the same schema.\n * @param data\n * @returns {promise}\n */\nvar generateHeading = function(data) {\n    if (options.KEYS) { return promise.resolve(options.KEYS); }\n\n    var keys = _.map(data, function (document, indx) { // for each key\n        if (_.isObject(document)) {\n            // if the data at the key is a document, then we retrieve the subHeading starting with an empty string heading and the doc\n            return generateDocumentHeading('', document);\n        }\n    });\n    \n    var uniqueKeys = [];\n\n    // If the user wants to check for the same schema:\n    if (options.CHECK_SCHEMA_DIFFERENCES) {\n        // Check for a consistent schema that does not require the same order:\n        // if we only have one document - then there is no possibility of multiple schemas\n        if (keys && keys.length <= 1) {\n            return promise.resolve(_.flatten(keys) || []);\n        }\n        // else - multiple documents - ensure only one schema (regardless of field ordering)\n        var firstDocSchema = _.flatten(keys[0]),\n            schemaDifferences = 0;\n\n        _.each(keys, function (keyList) {\n            // If there is a difference between the schemas, increment the counter of schema inconsistencies\n            var diff = _.difference(firstDocSchema, _.flatten(keyList));\n            if (!_.isEqual(diff, [])) {\n                schemaDifferences++;\n            }\n        });\n\n        // If there are schema inconsistencies, throw a schema not the same error\n        if (schemaDifferences) {\n            return promise.reject(new Error(constants.Errors.json2csv.notSameSchema));\n        }\n\n\n        uniqueKeys = _.flatten(keys[0]);\n    } else {\n        // Otherwise, we do not care if the schemas are different, so we should merge them via union:\n        _.each(keys, function (keyList) {\n            uniqueKeys = _.union(uniqueKeys, _.flatten(keyList));\n        });\n    }\n    \n    if (options.SORT_HEADER) {\n        uniqueKeys.sort();\n    }\n\n    return promise.resolve(uniqueKeys);\n};\n\n/**\n * Takes the parent heading and this doc's data and creates the subdocument headings (string)\n * @param heading\n * @param data\n * @returns {Array}\n */\nvar generateDocumentHeading = function(heading, data) {\n    var keyName = ''; // temporary variable to aid in determining the heading - used to generate the 'nested' headings\n\n    var documentKeys = _.map(_.keys(data), function (currentKey) {\n        // If the given heading is empty, then we set the heading to be the subKey, otherwise set it as a nested heading w/ a dot\n        keyName = heading ? heading + '.' + currentKey : currentKey;\n\n        // If we have another nested document, recur on the sub-document to retrieve the full key name\n        if (_.isObject(data[currentKey]) && !_.isNull(data[currentKey]) && !_.isArray(data[currentKey]) && _.keys(data[currentKey]).length) {\n            return generateDocumentHeading(keyName, data[currentKey]);\n        }\n        // Otherwise return this key name since we don't have a sub document\n        return keyName;\n    });\n    \n    return documentKeys; // Return the headings in an array\n};\n\n/**\n * Convert the given data with the given keys\n * @param data\n * @param keys\n * @returns {Array}\n */\nvar \nconvertData = function (data, keys) {\n    // Reduce each key in the data to its CSV value\n    return _.reduce(keys, function (output, key) {\n        // Retrieve the appropriate field data\n        var fieldData = path.evaluatePath(data, key);\n        if (_.isUndefined(fieldData)) { fieldData = options.EMPTY_FIELD_VALUE; }\n        // Add the CSV representation of the data at the key in the document to the output array\n        return output.concat(convertField(fieldData));\n    }, []);\n};\n\n/**\n * Convert the given value to the CSV representation of the value\n * @param value\n * @param output\n */\nvar convertField = function (value) {\n    if (_.isArray(value)) { // We have an array of values\n        var result = [];\n        value.forEach(function(item) {\n            if (_.isObject(item)) {\n                // use JSON stringify to convert objects in arrays, otherwise toString() will just return [object Object]\n                result.push(JSON.stringify(item));\n            } else {\n                result.push(convertValue(item));\n            }\n        });\n        return options.DELIMITER.WRAP + '[' + result.join(options.DELIMITER.ARRAY) + ']' + options.DELIMITER.WRAP;\n    } else if (_.isDate(value)) { // If we have a date\n        return options.DELIMITER.WRAP + convertValue(value) + options.DELIMITER.WRAP;\n    } else if (_.isObject(value)) { // If we have an object\n        return options.DELIMITER.WRAP + convertData(value, _.keys(value)) + options.DELIMITER.WRAP; // Push the recursively generated CSV\n    } else if (_.isNumber(value)) { // If we have a number (avoids 0 being converted to '')\n        return options.DELIMITER.WRAP + convertValue(value) + options.DELIMITER.WRAP;\n    } else if (_.isBoolean(value)) { // If we have a boolean (avoids false being converted to '')\n        return options.DELIMITER.WRAP + convertValue(value) + options.DELIMITER.WRAP;\n    }\n    value = options.DELIMITER.WRAP && value ? value.replace(new RegExp(options.DELIMITER.WRAP, 'g'), \"\\\\\"+options.DELIMITER.WRAP) : value;\n    return options.DELIMITER.WRAP + convertValue(value) + options.DELIMITER.WRAP; // Otherwise push the current value\n};\n\nvar convertValue = function (val) {\n    // Convert to string\n    val = _.isNull(val) || _.isUndefined(val) ? '' : val.toString();\n    \n    // Trim, if necessary, and return the correct value\n    return options.TRIM_FIELD_VALUES ? val.trim() : val;\n};\n\n/**\n * Generate the CSV representing the given data.\n * @param data\n * @param headingKeys\n * @returns {*}\n */\nvar generateCsv = function (data, headingKeys) {\n    // Reduce each JSON document in data to a CSV string and append it to the CSV accumulator\n    return [headingKeys].concat(_.reduce(data, function (csv, doc) {\n        return csv += convertData(doc, headingKeys).join(options.DELIMITER.FIELD) + options.DELIMITER.EOL;\n    }, ''));\n};\n\nmodule.exports = {\n\n    /**\n     * Internally exported json2csv function\n     * Takes options as a document, data as a JSON document array, and a callback that will be used to report the results\n     * @param opts Object options object\n     * @param data String csv string\n     * @param callback Function callback function\n     */\n    json2csv: function (opts, data, callback) {\n        // If a callback wasn't provided, throw an error\n        if (!callback) { throw new Error(constants.Errors.callbackRequired); }\n\n        // Shouldn't happen, but just in case\n        if (!opts) { return callback(new Error(constants.Errors.optionsRequired)); }\n        options = opts; // Options were passed, set the global options value\n\n        // If we don't receive data, report an error\n        if (!data) { return callback(new Error(constants.Errors.json2csv.cannotCallJson2CsvOn + data + '.')); }\n\n        // If the data was not a single document or an array of documents\n        if (!_.isObject(data)) {\n            return callback(new Error(constants.Errors.json2csv.dataNotArrayOfDocuments));  // Report the error back to the caller\n        }\n        // Single document, not an array\n        else if (_.isObject(data) && !data.length) {\n            data = [data]; // Convert to an array of the given document\n        }\n\n        // Retrieve the heading and then generate the CSV with the keys that are identified\n        generateHeading(data)\n            .then(_.partial(generateCsv, data))\n            .spread(function (csvHeading, csvData) {\n                // If the fields are supposed to be wrapped... (only perform this if we are actually prepending the header)\n                if (options.DELIMITER.WRAP && options.PREPEND_HEADER) {\n                    csvHeading = _.map(csvHeading, function(headingKey) {\n                        return options.DELIMITER.WRAP + headingKey + options.DELIMITER.WRAP;\n                    });\n                }\n                \n                if (options.TRIM_HEADER_FIELDS) {\n                    csvHeading = _.map(csvHeading, function (headingKey) {\n                        return headingKey.trim();\n                    });\n                }\n                \n                // If we are prepending the header, then join the csvHeading fields\n                if (options.PREPEND_HEADER) {\n                    csvHeading = csvHeading.join(options.DELIMITER.FIELD);\n                }\n\n                // If we are prepending the header, then join the header and data by EOL, otherwise just return the data\n                return callback(null, options.PREPEND_HEADER ? csvHeading + options.DELIMITER.EOL + csvData : csvData);\n            })\n            .catch(function (err) {\n                return callback(err);\n            });\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-json-2-csv/node_modules/json-2-csv/lib/csv-2-json.js":"'use strict';\n\nvar _ = require('underscore'),\n    path = require('doc-path'),\n    constants = require('./constants.json');\n\nvar options = {}; // Initialize the options - this will be populated when the csv2json function is called.\n\n/**\n * Generate the JSON heading from the CSV\n * @param lines\n * @param callback\n * @returns {*}\n */\nvar retrieveHeading = function (lines, callback) {\n    // If there are no lines passed in, return an error\n    if (!lines.length) {\n        return callback(new Error(constants.Errors.csv2json.noDataRetrieveHeading)); // Pass an error back to the user\n    }\n\n    // Generate and return the heading keys\n    return _.map(splitLine(lines[0]),\n        function (headerKey, index) {\n            return {\n                value: options.TRIM_HEADER_FIELDS ? headerKey.trim() : headerKey,\n                index: index\n            };\n        });\n};\n\n/**\n * Does the given value represent an array?\n * @param value\n * @returns {boolean}\n */\nvar isArrayRepresentation = function (value) {\n    // Verify that there is a value and it starts with '[' and ends with ']'\n    return (value && /^\\[.*\\]$/.test(value));\n};\n\n/**\n * Converts the value from a CSV 'array'\n * @param val\n * @returns {Array}\n */\nvar convertArrayRepresentation = function (arrayRepresentation) {\n    // Remove the '[' and ']' characters\n    arrayRepresentation = arrayRepresentation.replace(/(\\[|\\])/g, '');\n\n    // Split the arrayRepresentation into an array by the array delimiter\n    arrayRepresentation = arrayRepresentation.split(options.DELIMITER.ARRAY);\n\n    // Filter out non-empty strings\n    return _.filter(arrayRepresentation, function (value) {\n        return value;\n    });\n};\n\n/**\n * Create a JSON document with the given keys (designated by the CSV header)\n *   and the values (from the given line)\n * @param keys String[]\n * @param line String\n * @returns {Object} created json document\n */\nvar createDocument = function (keys, line) {\n    line = splitLine(line); // Split the line using the given field delimiter after trimming whitespace\n    var val; // Temporary variable to set the current key's value to\n\n    // Reduce the keys into a JSON document representing the given line\n    return _.reduce(keys, function (document, key) {\n        // If there is a value at the key's index in the line, set the value; otherwise null\n        val = line[key.index] ? line[key.index] : null;\n        \n        // If the user wants to trim field values, trim the value\n        val = options.TRIM_FIELD_VALUES && !_.isNull(val) ? val.trim() : val;\n\n        // If the value is an array representation, convert it\n        if (isArrayRepresentation(val)) {\n            val = convertArrayRepresentation(val);\n        }\n        // Otherwise add the key and value to the document\n        return path.setPath(document, key.value, val);\n    }, {});\n};\n\n/**\n * Main helper function to convert the CSV to the JSON document array\n * @param lines String[]\n * @param callback Function callback function\n * @returns {Array}\n */\nvar convertCSV = function (lines, callback) {\n    var generatedHeaders = retrieveHeading(lines, callback), // Retrieve the headings from the CSV, unless the user specified the keys\n        nonHeaderLines = lines.splice(1), // All lines except for the header line\n    // If the user provided keys, filter the generated keys to just the user provided keys so we also have the key index\n        headers = options.KEYS ? _.filter(generatedHeaders, function (headerKey) {\n            return _.contains(options.KEYS, headerKey.value);\n        }) : generatedHeaders;\n\n    return _.reduce(nonHeaderLines, function (documentArray, line) { // For each line, create the document and add it to the array of documents\n        if (!line) { return documentArray; } // skip over empty lines\n        var generatedDocument = createDocument(headers, line.trim());\n        return documentArray.concat(generatedDocument);\n    }, []);\n};\n\n/**\n * Helper function that splits a line so that we can handle wrapped fields\n * @param line\n */\nvar splitLine = function (line) {\n    // If the fields are not wrapped, return the line split by the field delimiter\n    if (!options.DELIMITER.WRAP) { return line.split(options.DELIMITER.FIELD); }\n\n    // Parse out the line...\n    var splitLine = [],\n        character,\n        charBefore,\n        charAfter,\n        lastCharacterIndex = line.length - 1,\n        stateVariables = {\n            insideWrapDelimiter: false,\n            parsingValue: true,\n            startIndex: 0\n        },\n        index = 0;\n\n    // Loop through each character in the line to identify where to split the values\n    while(index < line.length) {\n        // Current character\n        character  = line[index];\n        // Previous character\n        charBefore = index ? line[index - 1] : '';\n        // Next character\n        charAfter = index < lastCharacterIndex ? line[index + 1] : '';\n\n        // If we reached the end of the line, add the remaining value\n        if (index === lastCharacterIndex) {\n            splitLine.push(line.substring(stateVariables.startIndex, stateVariables.insideWrapDelimiter ? index : undefined));\n        }\n        // If the line starts with a wrap delimiter\n        else if (character === options.DELIMITER.WRAP && index === 0) {\n            stateVariables.insideWrapDelimiter = true;\n            stateVariables.parsingValue = true;\n            stateVariables.startIndex = index + 1;\n        }\n\n        // If we reached a wrap delimiter with a field delimiter after it (ie. *\",)\n        else if (character === options.DELIMITER.WRAP && charAfter === options.DELIMITER.FIELD) {\n            splitLine.push(line.substring(stateVariables.startIndex, index));\n            stateVariables.startIndex = index + 2; // next value starts after the field delimiter\n            stateVariables.insideWrapDelimiter = false;\n            stateVariables.parsingValue = false;\n        }\n        // If we reached a wrap delimiter with a field delimiter after it (ie. ,\"*)\n        else if (character === options.DELIMITER.WRAP && charBefore === options.DELIMITER.FIELD) {\n            if (stateVariables.parsingValue) {\n                splitLine.push(line.substring(stateVariables.startIndex, index-1));\n            }\n            stateVariables.insideWrapDelimiter = true;\n            stateVariables.parsingValue = true;\n            stateVariables.startIndex = index + 1;\n        }\n        // If we reached a field delimiter and are not inside the wrap delimiters (ie. *,*)\n        else if (character === options.DELIMITER.FIELD && charBefore !== options.DELIMITER.WRAP &&\n                    charAfter !== options.DELIMITER.WRAP && !stateVariables.insideWrapDelimiter &&\n                    stateVariables.parsingValue) {\n            splitLine.push(line.substring(stateVariables.startIndex, index));\n            stateVariables.startIndex = index + 1;\n        }\n        else if (character === options.DELIMITER.FIELD && charBefore === options.DELIMITER.WRAP &&\n                    charAfter !== options.DELIMITER.WRAP) {\n            stateVariables.insideWrapDelimiter = false;\n            stateVariables.parsingValue = true;\n            stateVariables.startIndex = index + 1;\n        }\n        else if (character === \"\\\\\" && charAfter === options.DELIMITER.WRAP && stateVariables.insideWrapDelimiter) {\n            line = line.slice(0, index) + line.slice(index+1); // Remove the current character from the line\n            index--; // Move to position before to prevent moving ahead and skipping a character\n            lastCharacterIndex--; // Update the value since we removed a character\n        }\n        // Otherwise increment to the next character\n        index++;\n    }\n\n    return splitLine;\n};\n\nmodule.exports = {\n\n    /**\n     * Internally exported csv2json function\n     * Takes options as a document, data as a CSV string, and a callback that will be used to report the results\n     * @param opts Object options object\n     * @param data String csv string\n     * @param callback Function callback function\n     */\n    csv2json: function (opts, data, callback) {\n        // If a callback wasn't provided, throw an error\n        if (!callback) { throw new Error(constants.Errors.callbackRequired); }\n\n        // Shouldn't happen, but just in case\n        if (!opts) { return callback(new Error(constants.Errors.optionsRequired)); }\n        options = opts; // Options were passed, set the global options value\n\n        // If we don't receive data, report an error\n        if (!data) { return callback(new Error(constants.Errors.csv2json.cannotCallCsv2JsonOn + data + '.')); }\n\n        // The data provided is not a string\n        if (!_.isString(data)) {\n            return callback(new Error(constants.Errors.csv2json.csvNotString)); // Report an error back to the caller\n        }\n\n        // Split the CSV into lines using the specified EOL option\n        var lines = data.split(options.DELIMITER.EOL),\n            json = convertCSV(lines, callback); // Retrieve the JSON document array\n        return callback(null, json); // Send the data back to the caller\n    }\n\n};\n"}